{"google":"UA-33850683-1","body":"﻿__Jumper__ is a pathfinding library designed for __uniform-cost 2D grid-based__ games featuring [Jump Point Search][] algorithm.<br/>\r\n__Jumper__ is (very) fast, lightweight and generates almost no memory overhead. As such, it might be an interesting option\r\nfor pathfinding computation on 2D maps.\r\nPlus, *Jumper* offers a clean API which makes it very friendly and easy-to-use.<br/>\r\n\r\n__Jumper__ is written in pure [Lua][]. Thus, it is not __framework-related__ and can be used in __any project__ embedding [Lua][] code.\r\n\r\n##Files##\r\n\r\n* [Jumper][] contains the library itself.\r\n* [Jumper_(Demo).love][] | [Jumper_(Demo).rar][] is a visual interactive demo.\r\n* [Jumper_(Tests).love][] | [Jumper_(Tests).rar][] is another demo which performs a set of benchmark tests.\r\n  \r\n##Usage##\r\n\r\nPlace the folder [Jumper][] inside your projet. Use *require* to load it.\r\n\r\n    local Jumper = require('Jumper.init')\r\n\r\n*Note : If your LUA path includes search for \"init.lua\" on folder opening, as [Löve][] Framework do, you can simply use: require('Jumper')*\r\n\r\nNow you must now setup a 2D matrix of __integers__ or __strings__ representing your world. Values stored in this matrix\r\nshould represent whether or not a cell on the matrix is walkable or not. If you choose for instance\r\n*0* for walkable tiles, __any other value__ will be considered as non walkable.\r\n\r\n    local map = {\r\n          {0,0,0},\r\n          {0,2,0},\r\n          {0,0,1},\r\n          }\r\n\r\nTo initialize the pathfinder, you will have to pass __four values__. \r\n\r\n    local walkable = 0\r\n    local allowDiagonal = true\r\n    local pather = Jumper(map,walkable,allowDiagonal,heuristic)\r\n  \r\nOnly the first argument is __required__, the __three others__ left are __optional__.\r\n* __map__ refers to the matrix representing the 2D world.\r\n* __walkable__ refers to the value representing walkable tiles. Will be considered as *0* if not given.\r\n* __allowDiagonal__ is a boolean saying whether or not diagonal moves are allowed. Will be considered as __true__ if not given.\r\n* __heuristic__ is a predefined constant representing the heuristic function to be used for path computation.\r\n\r\n##Distance heuristics##\r\n\r\n*Jumper* features 4 types of distance heuristics.\r\n\r\n* MANHATTAN Distance : <em>|dx| + |dy|</em>\r\n* EUCLIDIAN Distance : <em>sqrt(dx*dx + dy*dy)</em>\r\n* DIAGONAL Distance : <em>max(|dx|, |dy|)</em>\r\n* CHEBYSHEV Distance : <em>DIAGONAL(dx,dy)</em>\r\n\r\nEach of these distance heuristics are packed inside Jumper's core. By default, when initializing  *Jumper*, __MANHATTAN__ Distance is used if \r\nno heuristic was specified.<br/>\r\nIf you need to use __another distance heuristic__, you will need to __require all distance heuristics__ first.\r\nAll distance heuristics are defined inside [heuristics.lua][].\r\n\r\n    local walkable = 0\r\n    local allowDiagonal = true\r\n    local Heuristics. = require 'Jumper.core.heuristics'\r\n    local Jumper = require('Jumper.init')\r\n    local pather = Jumper(map,walkable,allowDiagonal,Heuristics.EUCLIDIAN)\r\n\r\nYou can __alternatively__ use *setHeuristic(Name)*. This way, __requiring distance heuristics is no more relevant__.\r\nThe __heuristic name__ to be passed to *setHeuristic()* method must be one of these following, with quotes:\r\n\r\n* __\"MANHATTAN\"__ (referring to MANHATTAN Distance)\r\n* __\"EUCLIDIAN\"__ (referring to EUCLIDIAN Distance)\r\n* __\"DIAGONAL\"__ or __\"CHEBYSHEV\"__ (referring to DIAGONAL Distance)\r\n\r\nAs an example :\r\n \r\n    local walkable = 0\r\n    local allowDiagonal = true\r\n    local Jumper = require('Jumper.init')\r\n    local pather = Jumper(map,walkable,allowDiagonal)\r\n    pather:setheuristic('EUCLIDIAN')\r\n\r\n##API##\r\n\r\n###Main Pathfinder Class API\r\n\r\nOnce loaded and initialized properly, you can now used one of the following methods listed below.<br/>\r\n__Assuming *pather* represents an instance of *Jumper* class.__\r\n\t\r\n####pather:setHeuristic(NAME)\r\nWill change the heuristic to be used.<br/>\r\n__NAME__ must be passed as a string.<br/>\r\nPossible values are __\"MANHATTAN\"__,__\"EUCLIDIAN\"__,__\"DIAGONAL\"__,__\"CHEBYSHEV\"__ (case-sensitive!).\r\n* __Argument NAME__: a string\r\n* __Returns:__ Nothing\r\n\r\n####pather:getHeuristic() \r\nWill return a reference to the __heuristic function__ internally used.<br/>\r\n* __Argument__: Nothing\r\n* __Returns:__ a function\r\n\r\n####pather:setDiagonalMoves(Bool)\r\nArgument must be a boolean. __true__ will authorize __diagonal moves__, __false__ will allow __only straight-moves__.<br/>\r\n* __Argument Bool__: a boolean\r\n* __Returns:__ Nothing\r\n\r\n####pather:getDiagonalMoves()\r\nReturns __a boolean__ saying whether or not diagonal moves are allowed.\r\n* __Argument__: Nothing\r\n* __Returns:__ a boolean\r\n\r\n####pather:getGrid()\r\nReturns a reference to the __internal grid__ used by the pathfinder.\r\nThis grid is __not__ the map matrix given on initialization, but a __virtual representation__ used internally.\r\n* __Argument__: Nothing\r\n* __Returns:__ a grid (regular Lua table)\r\n\r\n####pather:searchPath(startX,startY,endX,endY)\r\nMain function, returns a path from [startX,startY] to [endX,endY] as an __ordered array__ of locations ({x = ...,y = ...}).\r\nOtherwise returns __nil__ if there is __no valid path__.\r\nAlso returns a __second value__ representing __total cost of the move__ if a path was found.\r\n* __Argument startX__: The X coordinate of the starting node (positive non zero integer)\r\n* __Argument startY__: The Y coordinate of the starting node (positive non zero integer)\r\n* __Argument endX__: The X coordinate of the goal node (positive non zero integer)\r\n* __Argument endY__: The Y coordinate of the goal node (positive non zero integer)\r\n* __Returns:__ a path (regular Lua table) or nil\r\n* __Returns:__ the path cost (positive number) or nil\r\n\r\n####pather:smooth(Path)\r\nPolishes a path\r\n* __Argument Path__: a path (regular Lua table)\r\n* __Returns:__ a path (regular Lua table)\r\n\r\n###Grid Class API\r\n\r\nUsing *getGrid()* returns a reference to the internal grid used by the pathfinder.\r\nOn this reference, you can use one of the following methods.<br/>\r\n__Assuming *grid* holds the return value from *pather:getGrid()*__\r\n\r\n####grid:getNodeAt(x,y)\r\nReturns a reference to the node (X,Y) on the grid.\r\n\r\n* __Argument x__: the X coordinate of the requested node (positive non zero integer)\r\n* __Argument y__: the Y coordinate of the requested node (positive non zero integer)\r\n* __Returns:__ a node (regular Lua table)\r\n\r\n####grid:isWalkableAt(x,y)\r\nReturns a boolean saying whether or not the node (X,Y) __exists on the grid and is walkable__.\r\n* __Argument x__: the X coordinate of the requested node (positive non zero integer)\r\n* __Argument y__: the Y coordinate of the requested node (positive non zero integer)\r\n* __Returns:__ a boolean\r\n\r\n####grid:setWalkableAt(x,y,boolean)\r\nSets the node (X,Y) __walkable or not__ depending on the boolean given.\r\n__true__ makes the node walkable, while __false__ makes it unwalkable.\r\n* __Argument x__: the X coordinate of the requested node (positive non zero integer)\r\n* __Argument y__: the Y coordinate of the requested node (positive non zero integer)\r\n* __Argument boolean__: a boolean\r\n* __Returns:__ Nothing\r\n\r\n####grid:getNeighbours(node,allowDiagonal)\r\nReturns an array list of nodes __neighbouring location (X,Y)__.\r\nThe list will include or not adjacent nodes regards to the boolean __allowDiagonal__.\r\n* __Argument node__: a node (regular Lua table)\r\n* __Argument allowDiagonal__: a boolean\r\n* __Returns:__ list of neighbours (regular Lua table)\r\n\r\n####grid:reset()\r\nResets the grid. Called internally before each path computation, should not be used explicitely.\r\n* __Argument__: Nothing\r\n* __Returns:__ Nothing\r\n \r\n##Handling paths##\r\n\r\n###Using native *searchPath()* method###\r\n\r\nUsing *searchPath()* will return a table representing a path from one node to another.<br/>\r\nThe path is stored in a table using the form given below:\r\n\r\n    path = {\r\n              {x = 1,y = 1},\r\n              {x = 2,y = 2},\r\n              {x = 3,y = 3},\r\n              ...\r\n              {x = n,y = n},\r\n            }\r\n\t\t\t\r\nYou will have to make your own use of this to __route your entities__ on the 2D map along this path.<br/>\r\nNote that the path could contains some *holes* because of the algorithm used.<br/>\r\nHowever, this should not cause a serious issue as the move from one step to another along the path is always straight.\r\nYou can accomodate of this by yourself, or use the __path smoother__.\r\n\r\n###Using the path smoother###\r\n\r\n__Jumper__ provides a __path smoother__ that can be used to polish a path early computed, filling the holes it may contain.\r\nAs it directly alters the path given, both of these syntax works:\r\n\r\n    local walkable = 0\r\n    local allowDiagonal = true\r\n    local Jumper = require('Jumper.init')\r\n    -- Assuming map is defined\r\n    local pather = Jumper(map,walkable,allowDiagonal)\r\n    local path, length = pather:searchPath(1,1,3,3)\r\n    -- Capturing the returned value\r\n    path = pather:smooth(path)\r\n\t\r\n  \r\n    local walkable = 0\r\n    local allowDiagonal = true\r\n    local Jumper = require('Jumper.init')\r\n    -- Assuming map is defined\r\n    local pather = Jumper(map,walkable,allowDiagonal)\r\n    local path, length = pather:searchPath(1,1,3,3)\r\n    -- Just passing the path to the smoother.\r\n    pather:smooth(path)\r\n\t\r\n##Known Issues##\r\n\r\n* __Straight moves__ : you may find paths with only straight moves allowed somewhat odd under some circumstances (too much zigzags). This is something I am aware of, and expecting to fix next.\r\n\r\n##Participating Libraries##\r\n\r\n* [Lua Class System][]\r\n* [Binary heaps][]\r\n\r\n##About Visual Demo##\r\n\r\n*Jumper_(Demo)* is a visual demo of for the current library.<br/>\r\nYou can run it on __Windows__, __MAC__ & __Linux__ to experience the full amazing capabilities of __Jumper__.<br/>\r\n\r\n* __Love version__: [Jumper_(Demo).love][] (Requires [Löve 0.8.0 Framework][] to run, *Compatible Windows, Mac OSX, Linux*)\r\n* __Compiled Version for Windows (Stand-alone)__: [Jumper_(Demo).rar][]\r\n\r\n##About Benchmarking Tests##\r\n\r\n*Jumper_(Tests)* is a demo featuring benchmarking tests using the current library.<br/>\r\nYou can run it on __Windows__, __MAC__ & __Linux__.<br/>\r\nMaps included come from [Dragon Age : Origins][] and were taken on [Moving AI][].\r\n\r\n* __Love version__: [Jumper_(Tests).love][] (Requires [Löve 0.8.0 Framework][] to run, *Compatible Windows, Mac OSX, Linux*)\r\n* __Compiled Version for Windows (Stand-alone)__: [Jumper_(Tests).rar][]\r\n\r\n__Note:__While running Tests, you might be asked for outputting results.<br/>\r\nYou will find these outputs as __log files__ (regular Text files) on __different locations__ of your hard drive according to your __operating system__ :\r\n* __Windows XP__ : *C:\\Documents and Settings\\Your_Username\\Application Data\\Love\\Jumper\\* or *%appdata%\\Love\\Jumper\\*\r\n* __Windows Vista__ and __Win7__ : *C:\\Users\\Your_Username\\AppData\\Roaming\\LOVE\\Jumper\\* or *%appdata%\\Love\\Jumper\\*\r\n* __Linux__ : *$XDG_DATA_HOME/love/Jumper/* or ~/.local/share/love/Jumper/*\r\n* __Mac__ : */Users/Your_Username/Library/Application Support/LOVE/Jumper/*\r\n\r\n##Credits and Thanks##\r\n\r\n* [Daniel Harabor][], [Alban Grastien][] : for [technical papers][].<br/>\r\n* [XueXiao Xu][], [Nathan Witmer][]: for their amazing [port][] in Javascript<br/>\r\n* [Löve][] Development Team, for [Löve][] Framework.\r\n\r\n##License##\r\n\r\nThis work is under [MIT-LICENSE][]<br/>\r\nCopyright (c) 2012 Roland Yonaba\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a\r\n    copy of this software and associated documentation files (the\r\n    \"Software\"), to deal in the Software without restriction, including\r\n    without limitation the rights to use, copy, modify, merge, publish,\r\n    distribute, sublicense, and/or sell copies of the Software, and to\r\n    permit persons to whom the Software is furnished to do so, subject to\r\n    the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included\r\n    in all copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n[Jump Point Search]: http://harablog.wordpress.com/2011/09/07/jump-point-search/\r\n[Lua Class System]: http://yonaba.github.com/Lua-Class-System/\r\n[Lua]: http://lua.org\r\n[Binary heaps]: http://yonaba.github.com/Binary-Heaps/\r\n[Löve]: https://love2d.org\r\n[Löve 0.8.0 Framework]: https://love2d.org\r\n[Dragon Age : Origins]: http://dragonage.bioware.com\r\n[Moving AI]: http://movingai.com\r\n[Nathan Witmer]: https://github.com/aniero\r\n[XueXiao Xu]: https://github.com/qiao\r\n[port]: https://github.com/qiao/PathFinding.js\r\n[Alban Grastien]: http://www.grastien.net/ban/\r\n[Daniel Harabor]: http://users.cecs.anu.edu.au/~dharabor/home.html\r\n[technical papers]: http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf\r\n[MIT-LICENSE]: http://www.opensource.org/licenses/mit-license.php\r\n[Jumper]: https://github.com/Yonaba/Jumper/tree/master/Jumper\r\n[heuristics.lua]: https://github.com/Yonaba/Jumper/blob/master/Jumper/core/heuristics.lua\r\n[Jumper_(Demo).love]: https://github.com/downloads/Yonaba/Jumper/Jumper_(Demo).love\r\n[Jumper_(Tests).love]: https://github.com/downloads/Yonaba/Jumper/Jumper_(Tests).love\r\n[Jumper_(Demo).rar]: https://github.com/downloads/Yonaba/Jumper/Jumper_(Demo)_(Compiled%20For%20Windows).rar\r\n[Jumper_(Tests).rar]: https://github.com/downloads/Yonaba/Jumper/Jumper_(Tests)_(Compiled%20For%20Windows).rar","name":"Jumper","tagline":"Library for Fast Pathfinding on 2D Grid-based games featuring Jump Point Search Algorithm","note":"Don't delete this file! It's used internally to help with page regeneration."}